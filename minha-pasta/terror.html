<!DOCTYPE html>
<html>
<head>
    <title>Labirinto de Terror</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; font-family: 'Courier New', Courier, monospace;
            background-color: rgba(0, 0, 0, 0.8); text-align: center;
        }
        .overlay h1 { font-size: 4.5em; margin-bottom: 0; text-shadow: 3px 3px 10px red; }
        .overlay p { font-size: 1.2em; max-width: 600px; }
        .overlay button {
            padding: 15px 30px; font-size: 1.5em; background-color: #8B0000; color: white;
            border: 2px solid #FF4500; cursor: pointer; text-transform: uppercase; margin-top: 20px;
        }
        #hud {
            position: absolute; top: 20px; left: 20px; color: white; font-size: 2.5em;
            font-family: 'Helvetica', sans-serif; text-shadow: 2px 2px 4px #000000;
        }
        #sensitivity-container {
            position: absolute; bottom: 20px; right: 20px; color: white;
            font-family: Arial, sans-serif; background-color: rgba(0,0,0,0.5);
            padding: 10px; border-radius: 5px;
        }
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 150px rgba(255, 0, 0, 0);
            transition: box-shadow 0.5s ease-out;
        }
    </style>
</head>
<body>
    <div id="start-screen" class="overlay">
        <h1>Labirinto do Medo</h1>
        <p>Colete os 12 orbes de luz antes que ele te pegue.<br>Use Shift para correr.</p>
        <button id="start-button">Iniciar</button>
    </div>
    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1>Fim de Jogo</h1>
        <p>Você foi pego.</p>
        <button onclick="location.reload()">Tentar Novamente</button>
    </div>
    <div id="win-screen" class="overlay" style="display: none;">
        <h1>Você Venceu!</h1>
        <p>Você escapou... por enquanto.</p>
        <button onclick="location.reload()">Jogar Novamente</button>
    </div>
    
    <div id="hud" style="display: none;">Orbes: 12</div>
    <div id="sensitivity-container" style="display: none;">
        <label for="sensitivity">Sensibilidade:</label>
        <input type="range" id="sensitivity" min="0.001" max="0.01" step="0.001" value="0.003">
    </div>
    <div id="vignette"></div>

    <audio id="horror-soundtrack" loop>
        <source src="trilhasonora.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Módulo de PointerLockControls embutido
        const PointerLockControls = function (camera, domElement) { this.domElement = domElement; this.isLocked = false; const scope = this; const euler = new THREE.Euler(0, 0, 0, 'YXZ'); const PI_2 = Math.PI / 2; function onMouseMove(event) { if (scope.isLocked === false) return; const movementX = event.movementX || 0; const movementY = event.movementY || 0; euler.setFromQuaternion(camera.quaternion); euler.y -= movementX * playerState.mouseSensitivity; euler.x -= movementY * playerState.mouseSensitivity; euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); camera.quaternion.setFromEuler(euler); } function onPointerlockChange() { scope.isLocked = document.pointerLockElement === scope.domElement; } this.connect = function () { document.addEventListener('mousemove', onMouseMove, false); document.addEventListener('pointerlockchange', onPointerlockChange, false); }; this.lock = function () { this.domElement.requestPointerLock(); }; this.unlock = function () { document.exitPointerLock(); }; this.connect(); };

        let scene, camera, renderer, controls, clock;
        let player, enemy;
        let collectibles = [];
        let gameState = 'menu';

        const wallSize = 10;
        const wallHeight = 15;
        const totalOrbs = 12;
        const mazeLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        
        const keyboard = {};
        const playerState = {
            height: 6, walkSpeed: 8, sprintSpeed: 14,
            padding: 1.5, // CORRIGIDO: Adicionado um "preenchimento" para o jogador para colisões melhores
            mouseSensitivity: 0.003
        };

        const enemyState = {
            patrolSpeed: 3.5,
            // CORRIGIDO: Velocidade de perseguição do inimigo aumentada significativamente
            chaseSpeed: 11.0 
        };

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x05050a); scene.fog = new THREE.Fog(scene.background, 10, 75);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); player = camera;
            player.position.set(-65, playerState.height, -45); 
            clock = new THREE.Clock();
            controls = new PointerLockControls(camera, renderer.domElement);
            document.getElementById('start-button').addEventListener('click', startGame); document.addEventListener('click', () => { if(gameState === 'playing') controls.lock(); });
            document.getElementById('sensitivity').addEventListener('input', (e) => playerState.mouseSensitivity = parseFloat(e.target.value));
            
            createMaze(); createLights(); createCollectibles(); createEnemy();
            setupEventListeners();
            animate();
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('sensitivity-container').style.display = 'block';
            controls.lock();
            const audio = document.getElementById('horror-soundtrack');
            audio.volume = 0.3;
            audio.play().catch(e => console.error("Audio playback failed:", e));
        }

        function createMaze() {
            const wallTexture = new THREE.TextureLoader().load("https://www.textures.com/system/gallery/photos/Concrete/Bare/130189/ConcreteBare0252_1_S.jpg");
            wallTexture.wrapS = THREE.RepeatWrapping; wallTexture.wrapT = THREE.RepeatWrapping; wallTexture.repeat.set(1, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.8, metalness: 0.2 });
            const wallGeometry = new THREE.BoxGeometry(wallSize, wallHeight, wallSize);
            for (let i = 0; i < mazeLayout.length; i++) {
                for (let j = 0; j < mazeLayout[i].length; j++) {
                    if (mazeLayout[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set((j - mazeLayout[0].length / 2) * wallSize, wallHeight / 2, (i - mazeLayout.length / 2) * wallSize);
                        wall.castShadow = true; wall.receiveShadow = true;
                        scene.add(wall);
                    }
                }
            }
            const floorGeometry = new THREE.PlaneGeometry(wallSize * mazeLayout[0].length, wallSize * mazeLayout.length);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.9 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
            scene.add(floor);
        }

        function createLights() {
            scene.add(new THREE.AmbientLight(0x404040, 0.2));
            const playerLight = new THREE.SpotLight(0xffffff, 0.8, 60, Math.PI / 6, 0.5, 2);
            playerLight.castShadow = true;
            player.add(playerLight); playerLight.position.set(0, 0, 1);
            playerLight.target.position.set(0, 0, 2); player.add(playerLight.target);
            scene.add(player);
        }

        function createCollectibles() {
            const collectibleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const collectibleMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            let count = 0;
            while (count < totalOrbs) {
                const i = Math.floor(Math.random() * mazeLayout.length);
                const j = Math.floor(Math.random() * mazeLayout[0].length);
                if (mazeLayout[i][j] === 0) {
                    const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                    const light = new THREE.PointLight(0xffff00, 1, 10);
                    collectible.add(light);
                    collectible.position.set((j - mazeLayout[0].length / 2) * wallSize, playerState.height - 3, (i - mazeLayout.length / 2) * wallSize);
                    scene.add(collectible); collectibles.push(collectible);
                    mazeLayout[i][j] = 2; count++;
                }
            }
        }

        function createEnemy() {
            const enemyGeometry = new THREE.BoxGeometry(3, 8, 3);
            const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.5 });
            enemy = new THREE.Mesh(enemyGeometry, enemyMaterial); enemy.path = [];
            enemy.position.set(55, 4, 35);
            const enemyLight = new THREE.SpotLight(0xff0000, 2, 50, Math.PI / 4, 1, 2);
            enemyLight.castShadow = true; enemy.add(enemyLight);
            enemy.lightTarget = new THREE.Object3D(); enemy.add(enemy.lightTarget);
            enemyLight.target = enemy.lightTarget;
            scene.add(enemy);
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => { keyboard[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keyboard[e.key.toLowerCase()] = false; });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function getGridCoordinates(worldX, worldZ) {
            return { x: Math.floor((worldX / wallSize) + mazeLayout[0].length / 2), z: Math.floor((worldZ / wallSize) + mazeLayout.length / 2) };
        }

        function isWallAtWorld(worldX, worldZ) {
            const { x: gridX, z: gridZ } = getGridCoordinates(worldX, worldZ);
            if (gridZ < 0 || gridZ >= mazeLayout.length || gridX < 0 || gridX >= mazeLayout[0].length) return true;
            return mazeLayout[gridZ][gridX] === 1;
        }

        // CORRIGIDO: Lógica de movimento e colisão refeita para permitir "deslize" nas paredes.
        function updatePlayer(delta) {
            const currentSpeed = keyboard['shift'] ? playerState.sprintSpeed : playerState.walkSpeed;
            const moveSpeed = currentSpeed * delta;
            
            const moveDirection = new THREE.Vector3();
            if (keyboard['w'] || keyboard['arrowup']) moveDirection.z -= 1; if (keyboard['s'] || keyboard['arrowdown']) moveDirection.z += 1;
            if (keyboard['a'] || keyboard['arrowleft']) moveDirection.x -= 1; if (keyboard['d'] || keyboard['arrowright']) moveDirection.x += 1;
            moveDirection.normalize();

            if (moveDirection.length() > 0) {
                const moveVector = moveDirection.applyQuaternion(camera.quaternion);
                moveVector.y = 0;
                
                // Calcula a posição final desejada
                const intendedMove = moveVector.multiplyScalar(moveSpeed);

                // Checagem de colisão no eixo X
                if (!isWallAtWorld(player.position.x + intendedMove.x, player.position.z)) {
                    player.position.x += intendedMove.x;
                }

                // Checagem de colisão no eixo Z
                if (!isWallAtWorld(player.position.x, player.position.z + intendedMove.z)) {
                    player.position.z += intendedMove.z;
                }
            }

            // Head Bob
            const isMoving = moveDirection.length() > 0;
            const time = clock.getElapsedTime();
            if(isMoving){
                const bobFrequency = keyboard['shift'] ? 18 : 10;
                const bobAmplitude = 0.15;
                player.position.y = playerState.height + Math.sin(time * bobFrequency) * bobAmplitude;
            } else {
                player.position.y += (playerState.height - player.position.y) * 0.1;
            }
        }


        function updateEnemy(delta) {
            const currentEnemySpeed = (enemy.path && enemy.path.length > 0) ? enemyState.chaseSpeed : enemyState.patrolSpeed;

            if (clock.getElapsedTime() % 1 < delta) { 
                const playerCoords = getGridCoordinates(player.position.x, player.position.z);
                const enemyCoords = getGridCoordinates(enemy.position.x, enemy.position.z);
                enemy.path = findPath(enemyCoords, playerCoords);
            }

            if (enemy.path && enemy.path.length > 0) {
                const nextPos = enemy.path[0];
                const targetWorldPos = new THREE.Vector3((nextPos.x - mazeLayout[0].length / 2 + 0.5) * wallSize, enemy.position.y, (nextPos.z - mazeLayout.length / 2 + 0.5) * wallSize);
                const direction = targetWorldPos.clone().sub(enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(currentEnemySpeed * delta));
                enemy.lightTarget.position.copy(enemy.position).add(direction.multiplyScalar(10));
                if (enemy.position.distanceTo(targetWorldPos) < 1.0) enemy.path.shift();
            }
        }
        
        function findPath(start, end) { 
            const queue = [[start]]; const visited = new Set([`${start.x},${start.z}`]);
            while(queue.length > 0) {
                const path = queue.shift(); const pos = path[path.length - 1];
                if(pos.x === end.x && pos.z === end.z) return path.slice(1);
                const neighbors = [ {x: pos.x+1, z: pos.z}, {x: pos.x-1, z: pos.z}, {x: pos.x, z: pos.z+1}, {x: pos.x, z: pos.z-1} ];
                for(const n of neighbors) {
                    const gridX = Math.floor(n.x); const gridZ = Math.floor(n.z);
                    if(gridZ >= 0 && gridZ < mazeLayout.length && gridX >= 0 && gridX < mazeLayout[0].length &&
                       mazeLayout[gridZ][gridX] !== 1 && !visited.has(`${n.x},${n.z}`)) {
                        visited.add(`${n.x},${n.z}`); queue.push([...path, n]);
                    }
                }
            }
            return [];
        }
        
        function updateVignette() {
            const vignette = document.getElementById('vignette');
            if(enemy.path && enemy.path.length > 0) {
                const pulse = (Math.sin(clock.getElapsedTime() * 7) + 1) / 2;
                const opacity = 0.1 + pulse * 0.25;
                vignette.style.boxShadow = `inset 0 0 150px rgba(255, 0, 0, ${opacity})`;
            } else {
                vignette.style.boxShadow = `inset 0 0 150px rgba(255, 0, 0, 0)`;
            }
        }

        function checkCollisions() {
            const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const orbPos2D = new THREE.Vector2(collectibles[i].position.x, collectibles[i].position.z);
                if (playerPos2D.distanceTo(orbPos2D) < 2.0) {
                    scene.remove(collectibles[i]); collectibles.splice(i, 1);
                    document.getElementById('hud').innerText = `Orbes: ${collectibles.length}`;
                }
            }
            if (player.position.distanceTo(enemy.position) < 3) gameState = 'gameover';
            if (collectibles.length === 0) gameState = 'win';
        }
        
        function handleGameState() {
            if (gameState === 'gameover' || gameState === 'win') {
                const screenId = gameState === 'gameover' ? 'game-over-screen' : 'win-screen';
                document.getElementById(screenId).style.display = 'flex';
                controls.unlock();
                document.getElementById('hud').style.display = 'none';
                document.getElementById('sensitivity-container').style.display = 'none';
                document.getElementById('horror-soundtrack').pause();
                document.getElementById('vignette').style.display = 'none';
                gameState = 'finished';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (gameState === 'playing') {
                updatePlayer(delta); updateEnemy(delta);
                checkCollisions(); updateVignette();
                handleGameState();
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>