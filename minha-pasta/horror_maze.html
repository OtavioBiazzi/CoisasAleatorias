<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jogo: Labirinto de Terror (single HTML)</title>
  <style>
    html,body{height:100%;margin:0;background:#060507;color:#ddd;font-family:Inter,system-ui,Segoe UI,Arial}
    canvas{display:block}

    /* HUD & UI */
    #overlay{position:fixed;left:18px;top:18px;z-index:20;background:linear-gradient(180deg,rgba(0,0,0,0.55),rgba(0,0,0,0.25));padding:12px;border-radius:10px;backdrop-filter:blur(6px)}
    #title{font-weight:800;margin-bottom:6px;font-size:16px}
    #hud{position:fixed;right:12px;top:12px;z-index:20;background:rgba(0,0,0,0.28);padding:12px;border-radius:10px;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
    #hud button{padding:6px 10px;border-radius:6px;border:1px solid #333;background:#111;color:#fff;cursor:pointer}
    #hint{font-size:13px;color:#cfcfcf}

    /* Settings */
    #settings{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;padding:20px;background:rgba(6,6,8,0.98);border-radius:12px;display:none;min-width:360px;color:#ddd}
    .row{display:flex;align-items:center;gap:10px;margin:10px 0}
    label{flex:1;font-size:14px}
    input[type=range]{flex:2}

    /* Start menu (redone) */
    #startMenu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:100;background:linear-gradient(135deg,#0b0b0f,#141217);padding:28px;border-radius:14px;color:#fff;min-width:480px;text-align:center;box-shadow:0 10px 40px rgba(0,0,0,0.8)}
    #startMenu h1{font-size:34px;margin:0 0 6px 0;letter-spacing:1px}
    #startMenu p{color:#bdbdbd;margin:8px 0 18px}
    .diffRow{display:flex;justify-content:center;gap:14px;margin-bottom:18px}
    .difficulty{padding:10px 18px;border-radius:10px;background:#111;border:1px solid #333;cursor:pointer}
    .difficulty.selected{border-color:#ffd24d;background:#1a120b}
    #startGameBtn{padding:12px 22px;border-radius:12px;background:#8b0000;border:none;color:#fff;cursor:pointer;font-weight:700}

    /* minimap */
    #minimap{position:fixed;right:12px;bottom:12px;z-index:60;width:220px;height:220px;background:rgba(0,0,0,0.6);border-radius:8px;border:2px solid rgba(255,255,255,0.06);box-shadow:inset 0 0 20px rgba(0,0,0,0.6)}
    #minimap canvas{width:100%;height:100%;display:block;border-radius:6px}

    /* Caught overlay */
    #caughtOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:110;background:rgba(0,0,0,0.96);padding:18px;border-radius:12px;color:#fff;display:none;text-align:center}
    #caughtOverlay button{margin-top:12px;padding:10px 14px;background:#222;border:1px solid #444;color:#fff;border-radius:8px}

    /* small message */
    #message{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:10px 14px;border-radius:10px;color:#fff;z-index:95;display:none}
  </style>

  <!-- Import map for three -->
  <script async src="https://unpkg.com/es-module-shims@1.9.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="overlay">
    <div id="title">Labirinto do Medo</div>
    <div id="hint">WASD mover — Shift correr — F lanterna — E esconder — Esc configurações</div>
  </div>

  <div id="startMenu">
    <h1>Labirinto do Medo</h1>
    <p>Colete as orbes enquanto foge do que ronda os corredores. Minimap, esconderijos e dificuldade dinâmica.</p>
    <div class="diffRow">
      <div class="difficulty selected" data-diff="1">Fácil</div>
      <div class="difficulty" data-diff="2">Médio</div>
      <div class="difficulty" data-diff="3">Difícil</div>
    </div>
    <div style="display:flex;gap:12px;justify-content:center;align-items:center;margin-bottom:8px">
      <button id="startGameBtn">Iniciar</button>
    </div>
    <p style="font-size:13px;color:#bdbdbd;margin-top:6px;">Dica: esconda-se em armários (E) para recuperar stamina.</p>
  </div>

  <div id="hud">
    <div>Bolas: <span id="count">0</span>/<span id="total">0</span></div>
    <div>Vida: <span id="life">100</span></div>
    <div>Stamina: <span id="stamina">400</span></div>
    <div>Bateria: <span id="battery">∞</span></div>
    <div style="display:flex;gap:8px;margin-top:6px">
      <button id="btnLock">Prender cursor</button>
      <button id="btnToggleDrag">Ativar Drag-Look</button>
    </div>
  </div>

  <div id="settings">
    <h3 style="margin:0 0 6px 0;color:#fff">Configurações</h3>
    <div class="row"><label>Sensibilidade (mouse)</label><input id="sens" type="range" min="0.2" max="2.5" step="0.05" value="1"></div>
    <div class="row"><label>Vel. de corrida</label><input id="runspeed" type="range" min="6" max="24" step="0.5" value="12"></div>
    <div class="row"><label>Intensidade do camera shake</label><input id="shake" type="range" min="0" max="2.0" step="0.05" value="0.9"></div>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px"><button id="closeSettings" class="small">Fechar</button></div>
  </div>

  <div id="lockError" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#000;padding:14px;border-radius:10px;z-index:120;color:#fff">
    <div style="font-weight:700;margin-bottom:8px">Não foi possível prender o cursor</div>
    <div style="margin-bottom:8px">Se a página está embutida (iframe) ou sandboxed, o browser pode bloquear o Pointer Lock. Abra em nova aba ou use o modo de arrastar.</div>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="openNewTab">Abrir em nova aba</button>
      <button id="enableDragLook">Usar modo de arrastar</button>
      <button id="closeLockError">Fechar</button>
    </div>
  </div>

  <div id="minimap"><canvas id="minimapCanvas" width="220" height="220"></canvas></div>

  <!-- Audios: coloque os arquivos na pasta ./audio/ no seu repositório -->
  <audio id="horror-soundtrack" loop>
    <source src="./audio/trilhasonora.mp3" type="audio/mpeg">
  </audio>
  <audio id="sfx-pick" src="./audio/pickup.wav"></audio>
  <audio id="sfx-footstep" src="./audio/footstep.wav" loop></audio>
  <audio id="sfx-heart" src="./audio/heartbeat.mp3" loop></audio>

  <div id="message"></div>
  <div id="caughtOverlay"><h2>Você foi pego!</h2><div>O inimigo te encontrou — tente novamente.</div><button id="retryBtn">Tentar Novamente</button></div>

  <script type="module">
    import * as THREE from 'three';

    // ---------- Controls (same custom pointer lock) ----------
    function PointerLockControls_Custom(camera, domElement){
      this.domElement = domElement; this.isLocked = false; const scope = this; const euler = new THREE.Euler(0,0,0,'YXZ'); const PI_2 = Math.PI/2;
      function onMouseMove(event){ if(scope.isLocked === false) return; const movementX = event.movementX || 0; const movementY = event.movementY || 0; euler.setFromQuaternion(camera.quaternion); euler.y -= movementX * (sensitivity * 0.002); euler.x -= movementY * (sensitivity * 0.002); euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); camera.quaternion.setFromEuler(euler); }
      function onPointerlockChange(){ scope.isLocked = document.pointerLockElement === scope.domElement; }
      function onPointerlockError(e){ console.warn('PointerLock error', e); }
      this.connect = function(){ document.addEventListener('mousemove', onMouseMove, false); document.addEventListener('pointerlockchange', onPointerlockChange, false); document.addEventListener('pointerlockerror', onPointerlockError, false); };
      this.disconnect = function(){ document.removeEventListener('mousemove', onMouseMove, false); document.removeEventListener('pointerlockchange', onPointerlockChange, false); document.removeEventListener('pointerlockerror', onPointerlockError, false); };
      this.lock = function(){ if(this.domElement && this.domElement.requestPointerLock){ this.domElement.requestPointerLock(); } else { throw new Error('requestPointerLock não suportado neste elemento'); } };
      this.unlock = function(){ if(document.exitPointerLock) document.exitPointerLock(); };
      this.getObject = function(){ return camera; };
      this.connect();
    }

    // ---------- Game state ----------
    let difficulty = 1; let level = 1; const baseBallsForDifficulty = {1:8,2:10,3:12}; let targetBalls = baseBallsForDifficulty[difficulty];

    const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000006, 0.035);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000); camera.position.set(0,1.6,0);
    const renderer = new THREE.WebGLRenderer({ antialias:true }); renderer.setSize(innerWidth, innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;
    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

    const ambient = new THREE.HemisphereLight(0x444466, 0x080808, 0.6); scene.add(ambient);
    const moon = new THREE.DirectionalLight(0xffffff, 0.6); moon.position.set(5,10,2); scene.add(moon);
    const flashlight = new THREE.SpotLight(0xfff2cc, 3, 60, Math.PI*0.22, 0.2, 1); flashlight.castShadow = true; flashlight.shadow.mapSize.set(1024,1024); flashlight.visible = false; scene.add(flashlight);

    // Maze generation
    const MAZE = {cols:18, rows:18, cellSize:5}; const grid = [];
    function initGrid(){ for(let r=0;r<MAZE.rows;r++){ grid[r]=[]; for(let c=0;c<MAZE.cols;c++){ grid[r][c]={r,c, walls:[true,true,true,true], visited:false}; } } }
    function carve(){ const stack=[]; const start=grid[0][0]; start.visited=true; stack.push(start); while(stack.length){ const current=stack[stack.length-1]; const {r,c}=current; const neighbors=[]; if(r>0 && !grid[r-1][c].visited) neighbors.push({cell:grid[r-1][c],dir:0}); if(c<MAZE.cols-1 && !grid[r][c+1].visited) neighbors.push({cell:grid[r][c+1],dir:1}); if(r<MAZE.rows-1 && !grid[r+1][c].visited) neighbors.push({cell:grid[r+1][c],dir:2}); if(c>0 && !grid[r][c-1].visited) neighbors.push({cell:grid[r][c-1],dir:3}); if(neighbors.length){ const n = neighbors[Math.floor(Math.random()*neighbors.length)]; const next = n.cell; if(n.dir===0){ current.walls[0]=false; next.walls[2]=false; } if(n.dir===1){ current.walls[1]=false; next.walls[3]=false; } if(n.dir===2){ current.walls[2]=false; next.walls[0]=false; } if(n.dir===3){ current.walls[3]=false; next.walls[1]=false; } next.visited=true; stack.push(next); } else { stack.pop(); } } }
    function openUpMaze(){ const extraOpens = Math.floor(MAZE.cols*MAZE.rows*0.18) + Math.floor(level*1.2); for(let i=0;i<extraOpens;i++){ const r=Math.floor(Math.random()*MAZE.rows); const c=Math.floor(Math.random()*MAZE.cols); const cell=grid[r][c]; const dir=Math.floor(Math.random()*4); if(cell.walls[dir]){ cell.walls[dir]=false; const nr = r + (dir===2?1:dir===0?-1:0); const nc = c + (dir===1?1:dir===3?-1:0); if(nr>=0&&nr<MAZE.rows&&nc>=0&&nc<MAZE.cols) grid[nr][nc].walls[(dir+2)%4]=false; } } }

    function buildMazeMeshes(){ if(window.__wallGroup) scene.remove(window.__wallGroup); const wallGroupLocal = new THREE.Group(); const wallGeo = new THREE.BoxGeometry(MAZE.cellSize,4,0.6); const wallMat = new THREE.MeshStandardMaterial({color:0x222233,metalness:0.1,roughness:0.9});
      for(let r=0;r<MAZE.rows;r++){ for(let c=0;c<MAZE.cols;c++){ const cell = grid[r][c]; const cx = (c - MAZE.cols/2)*MAZE.cellSize + MAZE.cellSize/2; const cz = (r - MAZE.rows/2)*MAZE.cellSize + MAZE.cellSize/2; if(cell.walls[0]){ const w=new THREE.Mesh(wallGeo,wallMat); w.position.set(cx,2,cz - MAZE.cellSize/2); w.rotation.y=0; w.castShadow=true; w.receiveShadow=true; wallGroupLocal.add(w); } if(cell.walls[1]){ const w=new THREE.Mesh(wallGeo,wallMat); w.position.set(cx + MAZE.cellSize/2,2,cz); w.rotation.y=Math.PI/2; w.castShadow=true; w.receiveShadow=true; wallGroupLocal.add(w); } if(cell.walls[2]){ const w=new THREE.Mesh(wallGeo,wallMat); w.position.set(cx,2,cz + MAZE.cellSize/2); w.rotation.y=0; w.castShadow=true; w.receiveShadow=true; wallGroupLocal.add(w); } if(cell.walls[3]){ const w=new THREE.Mesh(wallGeo,wallMat); w.position.set(cx - MAZE.cellSize/2,2,cz); w.rotation.y=Math.PI/2; w.castShadow=true; w.receiveShadow=true; wallGroupLocal.add(w); } } }
      scene.add(wallGroupLocal); window.__wallGroup = wallGroupLocal; return wallGroupLocal; }

    const floorGeo = new THREE.PlaneGeometry(MAZE.cols*MAZE.cellSize,MAZE.rows*MAZE.cellSize,MAZE.cols,MAZE.rows); const floorMat = new THREE.MeshStandardMaterial({color:0x191919,metalness:0.1,roughness:0.95}); const floor = new THREE.Mesh(floorGeo,floorMat); floor.rotation.x = -Math.PI/2; floor.receiveShadow=true; scene.add(floor);

    // decoration
    const decoGroup = new THREE.Group(); const pillarGeo = new THREE.CylinderGeometry(0.4,0.5,3,12); const pillarMat = new THREE.MeshStandardMaterial({color:0x2a2a2a}); for(let i=0;i<20;i++){ const px = (Math.random()*MAZE.cols - MAZE.cols/2)*MAZE.cellSize; const pz = (Math.random()*MAZE.rows - MAZE.rows/2)*MAZE.cellSize; const p = new THREE.Mesh(pillarGeo,pillarMat); p.position.set(px,1.5,pz); p.castShadow=true; p.receiveShadow=true; decoGroup.add(p); } scene.add(decoGroup);

    // cabinets (avoid spawning inside walls)
    let cabinets = new THREE.Group(); function spawnCabinets(){ if(window.__cabinets) scene.remove(window.__cabinets); cabinets = new THREE.Group(); const cabGeo = new THREE.BoxGeometry(1.6,2.2,0.6); const cabMat = new THREE.MeshStandardMaterial({color:0x2b2b2b}); const count = 12 + Math.floor(level*2);
      let attempts=0; let placed=0; while(placed < count && attempts < count*30){ attempts++; // pick a random cell center and jitter a bit
        const r = Math.floor(Math.random()*MAZE.rows); const c = Math.floor(Math.random()*MAZE.cols); // avoid start & exit cells
        if((r===0 && c===0) || (r===MAZE.rows-1 && c===MAZE.cols-1)) continue;
        const cx = (c - MAZE.cols/2)*MAZE.cellSize + MAZE.cellSize/2 + (Math.random()-0.5)*1.0;
        const cz = (r - MAZE.rows/2)*MAZE.cellSize + MAZE.cellSize/2 + (Math.random()-0.5)*1.0;
        const cab = new THREE.Mesh(cabGeo,cabMat);
        cab.position.set(cx,1.1,cz);
        // quick collision check with walls and other cabinets
        if(checkCollision(cab.position)) continue;
        let tooClose=false; for(const other of cabinets.children){ if(cab.position.distanceTo(other.position) < 1.6) { tooClose=true; break; } }
        if(tooClose) continue;
        cab.userData.isCabinet=true; cab.userData.occupied=false; cabinets.add(cab); placed++; }
      scene.add(cabinets); window.__cabinets = cabinets; }

    // collectibles
    let collectibles = [];

    function generateLevel(){ initGrid(); carve(); openUpMaze(); buildMazeMeshes(); spawnCabinets();
      if(window.__collectGroup) scene.remove(window.__collectGroup);
      const collectGroup = new THREE.Group(); const ballGeo = new THREE.SphereGeometry(0.45,16,16); const ballMat = new THREE.MeshStandardMaterial({emissive:0xff5722,color:0x330000,metalness:0.6,roughness:0.2});
      collectibles.length = 0; const ballsToSpawn = targetBalls = baseBallsForDifficulty[difficulty] + (level-1)*2; let tries=0;
      while(collectibles.length<ballsToSpawn && tries<5000){ tries++; const r=Math.floor(Math.random()*MAZE.rows); const c=Math.floor(Math.random()*MAZE.cols); if(r===0&&c===0) continue; const cx = (c - MAZE.cols/2)*MAZE.cellSize + MAZE.cellSize/2 + (Math.random()-0.5)*1.2; const cz = (r - MAZE.rows/2)*MAZE.cellSize + MAZE.cellSize/2 + (Math.random()-0.5)*1.2; const ball = new THREE.Mesh(ballGeo,ballMat.clone()); ball.position.set(cx,1.2,cz); if(checkCollision(ball.position)) continue; ball.userData.collected=false; collectGroup.add(ball); collectibles.push(ball); }
      scene.add(collectGroup); window.__collectGroup = collectGroup;

      if(typeof controls !== 'undefined' && controls.getObject) controls.getObject().position.copy(cellCenter(0,0));
      enemy.position.copy(cellCenter(MAZE.rows-1, MAZE.cols-1)); enemy.position.y = 0;
      collected = 0; document.getElementById('count').innerText = collected; document.getElementById('total').innerText = targetBalls;
      exitGate && scene.remove(exitGate); exitGate = null;
      life = 100; stamina = 400; battery = Infinity; document.getElementById('life').innerText = life; document.getElementById('stamina').innerText = Math.round(stamina);
      enemy.path = [];
    }

    function cellCenter(r,c){ return new THREE.Vector3((c - MAZE.cols/2)*MAZE.cellSize + MAZE.cellSize/2, 1.6, (r - MAZE.rows/2)*MAZE.cellSize + MAZE.cellSize/2); }

    // --- Enemy: revert to simpler previous model (box) ---
    const enemy = new THREE.Group(); const enemyGeom = new THREE.BoxGeometry(1.2,2.2,1.2); const enemyMat = new THREE.MeshStandardMaterial({color:0x1a0606,metalness:0.1,roughness:0.9}); const enemyMesh = new THREE.Mesh(enemyGeom, enemyMat); enemyMesh.position.y = 1.1; enemy.add(enemyMesh); const eyeGeo = new THREE.SphereGeometry(0.09,8,8); const eyeMat = new THREE.MeshStandardMaterial({emissive:0xff2b2b,color:0x220000}); const e1 = new THREE.Mesh(eyeGeo,eyeMat); e1.position.set(0.26,1.9,0.38); enemy.add(e1); const e2 = e1.clone(); e2.position.x = -0.26; enemy.add(e2); enemy.position.set(0,0,0); scene.add(enemy);
    let enemySpeed = 1.0; const enemyRaycaster = new THREE.Raycaster();

    // HUD vars
    let collected = 0; let life = 100; let battery = Infinity; let stamina = 400; let isHidden=false; let hiddenCabinet=null; let gameOver=false;

    let exitGate = null; function spawnExit(){ if(exitGate) return; const ex = cellCenter(MAZE.rows-1, MAZE.cols-1); const ringGeo = new THREE.TorusGeometry(1.2,0.25,8,24); const ringMat = new THREE.MeshBasicMaterial({color:0x66ff66}); exitGate = new THREE.Mesh(ringGeo, ringMat); exitGate.position.copy(ex); exitGate.position.y = 1.6; scene.add(exitGate); }

    // audio
    const bgAudio = document.getElementById('horror-soundtrack'); const sfxPick = document.getElementById('sfx-pick'); const sfxFoot = document.getElementById('sfx-footstep'); const sfxHeart = document.getElementById('sfx-heart'); let musicReady=false; bgAudio.addEventListener('canplaythrough', ()=>{ musicReady=true; });
    function playSfx(el){ try{ el.currentTime = 0; el.play(); }catch(e){} }

    // Controls
    const controls = new PointerLockControls_Custom(camera, renderer.domElement);
    const blocker = document.getElementById('overlay'); blocker.addEventListener('click', ()=>{ renderer.domElement.focus(); safeLock(); });

    // pointer lock handling
    let lockBlocked=false; let dragLookEnabled=false; let isDragging=false; let lastDrag={x:0,y:0};
    function safeLock(){ try{ controls.lock(); }catch(err){ handleLockBlocked(err); } }
    function handleLockBlocked(err){ lockBlocked=true; document.getElementById('lockError').style.display='block'; showMessage('Pointer Lock bloqueado — usando fallback'); enableDragLook(); }
    document.addEventListener('pointerlockerror', (e)=>{ handleLockBlocked(e); });

    document.getElementById('btnLock').addEventListener('click', ()=>{ if(controls.isLocked) controls.unlock(); else safeLock(); });
    document.getElementById('btnToggleDrag').addEventListener('click', ()=>{ if(dragLookEnabled) { disableDragLook(); showMessage('Drag-Look desativado'); document.getElementById('btnToggleDrag').innerText='Ativar Drag-Look'; } else { enableDragLook(); showMessage('Drag-Look ativado'); document.getElementById('btnToggleDrag').innerText='Desativar Drag-Look'; } });

    document.getElementById('openNewTab').addEventListener('click', ()=>{ window.open(location.href, '_blank'); });
    document.getElementById('enableDragLook').addEventListener('click', ()=>{ enableDragLook(); document.getElementById('lockError').style.display='none'; });
    document.getElementById('closeLockError').addEventListener('click', ()=>{ document.getElementById('lockError').style.display='none'; });

    document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement === renderer.domElement){ lockBlocked=false; document.getElementById('lockError').style.display='none'; document.getElementById('overlay').style.display='none'; showMessage('Controles travados — boa sorte!'); disableDragLook(); if(musicReady) bgAudio.play().catch(()=>{}); document.getElementById('btnLock').innerText='Soltar cursor'; } else { document.getElementById('overlay').style.display='block'; document.getElementById('btnLock').innerText='Prender cursor'; } });

    // inputs
    const direction = new THREE.Vector3(); let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, running=false;
    const onKeyDown = (e)=>{ if(e.code==='KeyW') moveForward=true; if(e.code==='KeyS') moveBackward=true; if(e.code==='KeyA') moveLeft=true; if(e.code==='KeyD') moveRight=true; if(e.shiftKey) running=true; if(e.code==='KeyF') { flashlight.visible = !flashlight.visible; } if(e.code==='KeyE'){ if(!isHidden){ const nearby = findNearbyCabinet(); if(nearby){ isHidden=true; hiddenCabinet=nearby; showMessage('Escondido'); nearby.userData.occupied=true; controls.getObject().position.copy(nearby.position).add(new THREE.Vector3(0,0.2,0)); } } else { if(hiddenCabinet) hiddenCabinet.userData.occupied=false; isHidden=false; hiddenCabinet=null; showMessage('Saiu do esconderijo'); } } if(e.code==='Escape') toggleSettings(); };
    const onKeyUp = (e)=>{ if(e.code==='KeyW') moveForward=false; if(e.code==='KeyS') moveBackward=false; if(e.code==='KeyA') moveLeft=false; if(e.code==='KeyD') moveRight=false; if(!e.shiftKey) running=false; };
    document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);

    const sensSlider = document.getElementById('sens'); let sensitivity = parseFloat(sensSlider.value); sensSlider.addEventListener('input', ()=>sensitivity = parseFloat(sensSlider.value));

    function setControlRotationFromQuaternion(){ const quat = camera.quaternion; const e = new THREE.Euler().setFromQuaternion(quat,'YXZ'); yaw = e.y; pitch = e.x; }
    let yaw=0,pitch=0; setControlRotationFromQuaternion(); function setControlRotation(y,p){ const quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(p,y,0,'YXZ')); camera.quaternion.copy(quat); }

    // Drag-look
    function enableDragLook(){ if(dragLookEnabled) return; dragLookEnabled=true; renderer.domElement.style.cursor='grab'; renderer.domElement.addEventListener('mousedown', onDragStart); window.addEventListener('mouseup', onDragEnd); renderer.domElement.addEventListener('mousemove', onDragMove); document.getElementById('btnToggleDrag').innerText='Desativar Drag-Look'; }
    function disableDragLook(){ if(!dragLookEnabled) return; dragLookEnabled=false; renderer.domElement.style.cursor=''; renderer.domElement.removeEventListener('mousedown', onDragStart); window.removeEventListener('mouseup', onDragEnd); renderer.domElement.removeEventListener('mousemove', onDragMove); isDragging=false; document.getElementById('btnToggleDrag').innerText='Ativar Drag-Look'; }
    function onDragStart(e){ if(e.button!==0) return; isDragging=true; renderer.domElement.style.cursor='grabbing'; lastDrag.x=e.clientX; lastDrag.y=e.clientY; }
    function onDragEnd(e){ if(e.button!==0) return; isDragging=false; renderer.domElement.style.cursor='grab'; }
    function onDragMove(e){ if(!isDragging) return; const dx=e.clientX-lastDrag.x; const dy=e.clientY-lastDrag.y; lastDrag.x=e.clientX; lastDrag.y=e.clientY; yaw-=dx*0.002*sensitivity; pitch-=dy*0.002*sensitivity; pitch=Math.max(-Math.PI/2+0.05,Math.min(Math.PI/2-0.05,pitch)); setControlRotation(yaw,pitch); }

    function findNearbyCabinet(){ let nearest=null; let nd=999; const pos=controls.getObject().position; cabinets.children.forEach(c=>{ const d = pos.distanceTo(c.position); if(d<2.0 && !c.userData.occupied && d<nd){ nearest=c; nd=d; } }); return nearest; }

    // collision helper used for both player and objects
    function checkCollision(pos){ const r=0.45; if(window.__wallGroup){ for(const w of window.__wallGroup.children){ const box = new THREE.Box3().setFromObject(w); if(box.expandByScalar(r).containsPoint(pos)) return true; } } for(const c of cabinets.children){ const box = new THREE.Box3().setFromObject(c); if(box.expandByScalar(0.4).containsPoint(pos)) return true; } return false; }

    function buildInputDirection(){ const dx=(moveRight?1:0)+(moveLeft?-1:0); const dz=(moveForward?1:0)+(moveBackward?-1:0); direction.set(dx,0,dz); if(direction.length()>1) direction.normalize(); }

    // Pathfinding A*
    function neighborsForCell(r,c){ const res=[]; const cell=grid[r][c]; if(!cell.walls[0] && r>0) res.push({r:r-1,c}); if(!cell.walls[1] && c<MAZE.cols-1) res.push({r,c:c+1}); if(!cell.walls[2] && r<MAZE.rows-1) res.push({r:r+1,c}); if(!cell.walls[3] && c>0) res.push({r,c:c-1}); return res; }
    function heuristic(a,b){ return Math.abs(a.r-b.r)+Math.abs(a.c-b.c); }
    function findPathAStar(start,end){ const key=(p)=>`${p.r},${p.c}`; const open=new Map(); const closed=new Set(); const gScore=new Map(); const fScore=new Map(); open.set(key(start),start); gScore.set(key(start),0); fScore.set(key(start),heuristic(start,end)); const cameFrom=new Map(); while(open.size>0){ let currentKey=null; let current=null; let minF=Infinity; for(const [k,v] of open){ const f=fScore.get(k)||Infinity; if(f<minF){ minF=f; currentKey=k; current=v; } } if(!current) break; if(current.r===end.r && current.c===end.c){ const path=[]; let curKey=currentKey; while(cameFrom.has(curKey)){ const parts=curKey.split(','); path.unshift({r:parseInt(parts[0]), c:parseInt(parts[1])}); curKey = cameFrom.get(curKey); } return path; } open.delete(currentKey); closed.add(currentKey); for(const n of neighborsForCell(current.r,current.c)){ const nk=key(n); if(closed.has(nk)) continue; const tentativeG=(gScore.get(currentKey)||Infinity)+1; if(!open.has(nk) || tentativeG < (gScore.get(nk)||Infinity)){ cameFrom.set(nk,currentKey); gScore.set(nk,tentativeG); fScore.set(nk,tentativeG+heuristic(n,end)); open.set(nk,n); } } } return []; }

    // Minimap
    const miniCanvas = document.getElementById('minimapCanvas'); const miniCtx = miniCanvas.getContext('2d');
    function drawMinimap(){ const w=miniCanvas.width, h=miniCanvas.height; miniCtx.clearRect(0,0,w,h); miniCtx.fillStyle='rgba(8,8,8,0.9)'; miniCtx.fillRect(0,0,w,h); const cols=MAZE.cols, rows=MAZE.rows; const cellW=w/cols, cellH=h/rows; miniCtx.strokeStyle='rgba(200,200,200,0.12)'; miniCtx.lineWidth=1; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ const cell=grid[r][c]; const x=c*cellW, y=r*cellH; if(cell.walls[0]){ miniCtx.beginPath(); miniCtx.moveTo(x,y); miniCtx.lineTo(x+cellW,y); miniCtx.stroke(); } if(cell.walls[1]){ miniCtx.beginPath(); miniCtx.moveTo(x+cellW,y); miniCtx.lineTo(x+cellW,y+cellH); miniCtx.stroke(); } if(cell.walls[2]){ miniCtx.beginPath(); miniCtx.moveTo(x,y+cellH); miniCtx.lineTo(x+cellW,y+cellH); miniCtx.stroke(); } if(cell.walls[3]){ miniCtx.beginPath(); miniCtx.moveTo(x,y); miniCtx.lineTo(x,y+cellH); miniCtx.stroke(); } } } collectibles.forEach(b=>{ const gx=Math.floor((b.position.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize); const gy=Math.floor((b.position.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize); const x=gx*cellW+cellW/2; const y=gy*cellH+cellH/2; miniCtx.beginPath(); miniCtx.fillStyle=b.userData.collected ? 'gray' : '#ffd24d'; miniCtx.arc(x,y,Math.max(2,cellW*0.12),0,Math.PI*2); miniCtx.fill(); }); cabinets.children.forEach(c=>{ const gx=Math.floor((c.position.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize); const gy=Math.floor((c.position.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize); const x=gx*cellW+cellW*0.2; const y=gy*cellH+cellH*0.2; miniCtx.fillStyle='brown'; miniCtx.fillRect(x,y,cellW*0.6,cellH*0.6); }); const eGX=Math.floor((enemy.position.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize); const eGY=Math.floor((enemy.position.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize); miniCtx.fillStyle='red'; miniCtx.fillRect(eGX*cellW+cellW*0.42,eGY*cellH+cellH*0.42,cellW*0.16,cellH*0.16); const pGX=Math.floor((controls.getObject().position.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize); const pGY=Math.floor((controls.getObject().position.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize); miniCtx.fillStyle='white'; miniCtx.beginPath(); miniCtx.arc(pGX*cellW+cellW/2,pGY*cellH+cellH/2,Math.max(3,cellW*0.18),0,Math.PI*2); miniCtx.fill(); }

    // Main loop
    let footPlaying=false; const clock=new THREE.Clock(); let lastPathCompute=0;
    function animate(){ if(gameOver){ renderer.render(scene,camera); requestAnimationFrame(animate); return; } const dt=Math.min(0.05, clock.getDelta());
      // movement (player) with axis-based collision so player doesn't lock into walls
      if(!isHidden){ const runVal = parseFloat(document.getElementById('runspeed').value || '12'); const speed = (running && stamina>10) ? runVal : 5.0; const actual = speed*dt; buildInputDirection(); const forward=new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize(); const right=new THREE.Vector3(); right.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize(); const moveVec = new THREE.Vector3(); moveVec.copy(forward).multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)); if(moveVec.length()>0){ moveVec.normalize(); const dx = moveVec.x * actual; const dz = moveVec.z * actual; const cur = controls.getObject().position.clone(); // try X then Z for sliding
            const attemptX = cur.clone().add(new THREE.Vector3(dx,0,0)); const attemptZ = cur.clone().add(new THREE.Vector3(0,0,dz)); const attemptBoth = cur.clone().add(new THREE.Vector3(dx,0,dz)); let moved=false; if(!checkCollision(attemptBoth)){ controls.getObject().position.copy(attemptBoth); moved=true; } else { if(!checkCollision(attemptX)){ controls.getObject().position.copy(attemptX); moved=true; } if(!checkCollision(attemptZ)){ controls.getObject().position.copy(attemptZ); moved=true; } }
            if(moved){ if(!footPlaying && !dragLookEnabled && (controls.isLocked || dragLookEnabled)){ playSfx(sfxFoot); footPlaying=true; } } else { if(footPlaying){ sfxFoot.pause(); sfxFoot.currentTime=0; footPlaying=false; } }
          } else { if(footPlaying){ sfxFoot.pause(); sfxFoot.currentTime=0; footPlaying=false; } }
        if(running && direction.length()>0 && stamina>0){ stamina = Math.max(0, stamina - dt*26); } else { stamina = Math.min(400, stamina + dt*18); } }
      else { stamina = Math.min(400, stamina + dt*36); }
      document.getElementById('stamina').innerText = Math.round(stamina);

      // flashlight unlimited
      document.getElementById('battery').innerText = '∞'; flashlight.position.copy(camera.position); const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir); flashlight.target.position.copy(camera.position.clone().add(camDir.multiplyScalar(10)));

      // collectibles pickup
      const playerPos = controls.getObject().position.clone(); for(const b of collectibles){ if(b.userData.collected) continue; const dx=b.position.x - playerPos.x; const dz=b.position.z - playerPos.z; const horiz = Math.sqrt(dx*dx + dz*dz); const pickupRadius = 1.6; if(horiz < pickupRadius){ b.userData.collected = true; b.material.emissive = new THREE.Color(0x444444); b.material.color = new THREE.Color(0x555555); playSfx(sfxPick); collected++; document.getElementById('count').innerText = collected; if(collected>=targetBalls){ showMessage('Você coletou todas as bolas do nível — procure a saída!'); spawnExit(); } } }

      // heartbeat SFX
      const enemyPos = enemy.position.clone(); const dist = playerPos.distanceTo(enemyPos);
      if(dist < 8){ if(sfxHeart.paused) playSfx(sfxHeart); sfxHeart.volume = Math.min(1,(8-dist)/8); } else { if(!sfxHeart.paused){ sfxHeart.pause(); sfxHeart.currentTime=0; } }

      // exit check
      if(exitGate && collected >= targetBalls){ const exPos=exitGate.position.clone(); const dx=exPos.x - playerPos.x; const dz=exPos.z - playerPos.z; if(Math.sqrt(dx*dx + dz*dz) < 1.2){ showMessage('Nível concluído! Gerando próximo nível...',3000); level++; setTimeout(()=>{ generateLevel(); }, 900); } }

      // enemy pathfinding (A*) and movement with collision
      lastPathCompute += dt;
      const pGrid = {r: Math.floor((playerPos.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize), c: Math.floor((playerPos.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize)};
      const eGrid = {r: Math.floor((enemy.position.z + (MAZE.rows*MAZE.cellSize)/2)/MAZE.cellSize), c: Math.floor((enemy.position.x + (MAZE.cols*MAZE.cellSize)/2)/MAZE.cellSize)};
      if((lastPathCompute>0.35) || !enemy.path || enemy.path.length===0){ lastPathCompute = 0; if(pGrid.r>=0 && pGrid.r<MAZE.rows && pGrid.c>=0 && pGrid.c<MAZE.cols && eGrid.r>=0 && eGrid.r<MAZE.rows && eGrid.c>=0 && eGrid.c<MAZE.cols){ const rawPath = findPathAStar(eGrid,pGrid); enemy.path = rawPath; } }

      // dynamic enemy speed: match player's sprint speed (runspeed slider)
      const runVal = parseFloat(document.getElementById('runspeed').value || '12');
      if(enemy.path && enemy.path.length>0){ const nextCell = enemy.path[0]; const targetWorld = cellCenter(nextCell.r,nextCell.c); targetWorld.y = enemy.position.y; const dir = targetWorld.clone().sub(enemy.position); const distToNode = dir.length(); if(distToNode < 0.35){ enemy.path.shift(); } else { dir.normalize(); const closenessBoost = Math.max(0, (12 - Math.min(dist, 12)) * 0.12); // enemy speed equals player's sprint speed, slightly faster by difficulty
            enemySpeed = runVal * (isHidden?0.45:1.0) + (difficulty-1)*2.0 + level*0.35 + closenessBoost;
            const moveAmount = enemySpeed * dt; const candidate = enemy.position.clone().add(dir.clone().multiplyScalar(moveAmount)); // check collision for enemy
            if(!checkCollision(candidate)){ enemy.position.copy(candidate); } else { // try axis sliding
              const candX = enemy.position.clone().add(new THREE.Vector3(dir.x,0,0).multiplyScalar(moveAmount)); const candZ = enemy.position.clone().add(new THREE.Vector3(0,0,dir.z).multiplyScalar(moveAmount)); if(!checkCollision(candX)) enemy.position.copy(candX); else if(!checkCollision(candZ)) enemy.position.copy(candZ); // else stay
            } } }
      else { const direct = playerPos.clone().sub(enemy.position); direct.y=0; const dlen = direct.length(); if(dlen>0.1){ direct.normalize(); enemySpeed = runVal * (isHidden?0.45:0.9) + (difficulty-1)*1.2 + level*0.2; const moveAmount = enemySpeed * dt; const candidate = enemy.position.clone().add(direct.clone().multiplyScalar(moveAmount)); if(!checkCollision(candidate)) enemy.position.copy(candidate); } }

      enemy.lookAt(playerPos.x, enemy.position.y+1.2, playerPos.z);

      // camera shake: stronger if enemy is fast or close; shake scales with running
      const speedFactor = Math.min(1, enemySpeed / Math.max(1, runVal)); const proximity = Math.max(0, 1 - dist/8); const runIntensity = running ? 1.2 : 0.6; const shakeAmount = proximity * speedFactor * runIntensity * parseFloat(document.getElementById('shake').value);
      if(shakeAmount>0.02) applyShake(shakeAmount);

      // caught check
      if(dist < 1.4){ onPlayerCaught(); }

      drawMinimap(); renderer.render(scene,camera); requestAnimationFrame(animate);
    }

    function onPlayerCaught(){ if(gameOver) return; gameOver=true; document.getElementById('caughtOverlay').style.display='block'; showMessage('Você foi pego!'); sfxFoot.pause(); sfxFoot.currentTime=0; if(!sfxHeart.paused){ sfxHeart.pause(); sfxHeart.currentTime=0; } controls.unlock(); }
    document.getElementById('retryBtn').addEventListener('click', ()=>{ document.getElementById('caughtOverlay').style.display='none'; gameOver=false; generateLevel(); safeLock(); });

    function applyShake(amount){ const t=performance.now()*0.001; const sx=(Math.sin(t*80)*0.5 + (Math.random()-0.5))*amount*0.12; const sy=(Math.cos(t*60)*0.5 + (Math.random()-0.5))*amount*0.12; camera.rotation.x += sx; camera.rotation.z += sy*0.25; }

    scene.add(flashlight.target);

    function runSelfTests(){ try{ console.assert(THREE && THREE.WebGLRenderer, 'THREE não carregado'); console.assert(typeof PointerLockControls_Custom === 'function', 'PointerLockControls ausente'); console.assert(renderer instanceof THREE.WebGLRenderer, 'Renderer não criado'); console.assert(scene.fog, 'Névoa não aplicada'); console.log('[Teste] OK'); }catch(err){ showMessage('Falha nos testes: '+ err.message, 6000); console.error(err); } }

    // UI helpers
    const messageEl = document.getElementById('message'); let msgTimer=null; function showMessage(t,time=3500){ messageEl.style.display='block'; messageEl.innerText=t; clearTimeout(msgTimer); msgTimer=setTimeout(()=>messageEl.style.display='none',time); }

    // Menu interactions
    document.querySelectorAll('.difficulty').forEach(el=>el.addEventListener('click', (e)=>{ document.querySelectorAll('.difficulty').forEach(x=>x.classList.remove('selected')); el.classList.add('selected'); difficulty = parseInt(el.dataset.diff); }));
    document.getElementById('startGameBtn').addEventListener('click', ()=>{ document.getElementById('startMenu').style.display='none'; targetBalls = baseBallsForDifficulty[difficulty]; level = 1; generateLevel(); animate(); runSelfTests(); safeLock(); });

    // settings wiring
    document.getElementById('closeSettings').addEventListener('click', ()=>{ document.getElementById('settings').style.display='none'; safeLock(); });

    // pointer lock sync
    document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement === renderer.domElement) document.getElementById('btnLock').innerText='Soltar cursor'; else document.getElementById('btnLock').innerText='Prender cursor'; });

    showMessage('Bem-vindo — escolha uma dificuldade e pressione Iniciar'); window.addEventListener('contextmenu', e=>e.preventDefault());

  </script>
</body>
</html>
